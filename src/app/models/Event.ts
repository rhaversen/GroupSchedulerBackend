import { type Document, model, Schema } from 'mongoose'

import UserModel from './User.js'

export interface ITimeRange {
	start: number
	end: number
}

export interface IMember {
	/** User ID of the member */
	userId: Schema.Types.ObjectId | string
	/** Role of the member in the event
	 * - 'creator': The user who created the event.
	 * - 'admin': A user with administrative privileges for the event.
	 * - 'participant': A regular participant in the event.
	 */
	role: 'creator' | 'admin' | 'participant'
	/**
	 * Custom padding after the event for the user, in milliseconds
	 * This can only be set and seen by the member themselves.
	 * This is optional and can be used to constrict how soon a new event can be scheduled after this one.
	 */
	customPaddingAfter?: number
	/** Availability status of the member for the event
	 * - 'available': The member is available for the event.
	 * - 'unavailable': The member is not available for the event.
	 * - 'invited': The member has been invited to the event but has not yet responded.
	 * This can only be set by the member themselves, but read by all members.
	 */
	availabilityStatus: 'available' | 'unavailable' | 'invited'
}

export interface IEvent extends Document {
	_id: Schema.Types.ObjectId
	id: string

	/** Name of the event */
	name: string
	/** Description of the event */
	description?: string

	/** Event members with their roles */
	members: IMember[]

	/**
	 * - 'fixed': Event has a specific time window and duration.
	 * - 'flexible': Event can be scheduled within a broader time range.
	 */
	schedulingMethod: 'fixed' | 'flexible'

	/** Duration of the event in milliseconds */
	duration: number
	/** Possible times when the event can be scheduled (milliseconds since epoch) */
	timeWindow?: ITimeRange

	/** Lifecycle status of the event
	 * - 'scheduling': Event is being scheduled. It may or may not have a tentative scheduled time.
	 * - 'confirmed': Event has been confirmed with a scheduled time.
	 * - 'cancelled': Event has been cancelled and will not occur.
	*/
	status: 'scheduling' | 'confirmed' | 'cancelled'
	/** The current scheduled time for the event, if any */
	scheduledTime?: number

	/** Visibility of the event */
	visibility: 'draft' | 'public' | 'private'

	/** Blackout periods where the event cannot be scheduled */
	blackoutPeriods?: ITimeRange[]
	/** Preferred times for the event */
	preferredTimes?: ITimeRange[]
	/** Intra-day start constraint for the event, in milliseconds of the day */
	dailyStartConstraints?: ITimeRange[]

	createdAt: Date
	updatedAt: Date
}

export interface IEventFrontend {
	/**
	 * ID of the event
	 * - This is a unique identifier for the event, used to reference it in the database.
	 * - It is a string that is generated by the database.
	 */
	_id: string

	/**
	 * Name of the event
	 * - This is a short, descriptive name for the event.
	 * - Maximum length is 50 characters.
	 */
	name: string

	/**
	 * Description of the event
	 * - This is a longer, more detailed description of the event.
	 * - Maximum length is 1000 characters.
	 * - This can be left undefined/null if no description is provided.
	 */
	description?: string

	/**
	 * Members of the event
	 * - Each member has a userId, role, and availability status.
	 * - `userId`: ID of the user.
	 * - `role`: Role of the user in the event, can be 'creator', 'admin', or 'participant'.
	 * - `availabilityStatus`: Status of the user's availability for the event, can be 'available', 'unavailable', or 'invited'. This can only be set by the member themselves, but read by all members.
	 */
	members: {
		/** User ID of the member */
		userId: string
		/** Role of the member in the event
		 * - `creator` The user who created the event.
		 * - `admin` A user with administrative privileges for the event.
		 * - `participant` A regular participant in the event.
		 */
		role: 'creator' | 'admin' | 'participant'
		/** Availability status of the member for the event
		 * - `available` The member is available for the event.
		 * - `unavailable` The member is not available for the event.
		 * - `invited` The member has been invited to the event but has not yet responded.
		 * - This can only be set by the member themselves, but read by all members.
		 */
		availabilityStatus: 'available' | 'unavailable' | 'invited'
	}[]

	/**
	 * Scheduling method for the event
	 * - `fixed` Event has a fixed time and cannot be changed.
	 * - `flexible` Event will be scheduled at any time within the specified time window, subject to constraints.
	 */
	schedulingMethod: 'fixed' | 'flexible'

	/**
	 * Duration of the event in ms
	 * - This is used to determine how long the event will last.
	 * - If the schedulingMethod is 'flexible', this will be used to determine available times for the event.
	 * - If the schedulingMethod is 'fixed', this will be used to determine the end time of the event. It should be calculated as the difference between the start time and a "virtual" end time UI element of the event.
	 */
	duration: number

	/**
	 * Time window for the event
	 * - `timeWindow.start` Start time of the time window in milliseconds since epoch.
	 * - `timeWindow.end` End time of the time window in milliseconds since epoch.
	 * - This is used to determine when the event can occur for flexible scheduling.
	 * - If the schedulingMethod is 'fixed', this will be ignored.
	 */
	timeWindow?: ITimeRange

	/** Lifecycle status of the event
	 * - `scheduling` Event is being scheduled. It may or may not have a tentative scheduled time.
	 * - `confirmed` Event has been confirmed with a scheduled time. The scheduled time is set and cannot be changed.
	 * - `cancelled` Event has been cancelled and will not occur, despite having a scheduled time.
	*/
	status: 'scheduling' | 'confirmed' | 'cancelled'

	/**
	 * The current scheduled time for the event, if any.
	 * - This can only be set when the schedulingMethod is 'fixed'.
	 * - If the schedulingMethod is 'flexible', this will automatically be determined based on the preferred times and constraints.
	 * - If the event is in 'scheduling' status, this may be null.
	 * - If the event is in 'confirmed' status, this will be a valid timestamp.
	 */
	scheduledTime?: number

	/**
	 * Visibility of the event
	 * - `draft` Event is in draft state, not visible to any users except for creators and admins.
	 * - `public` Event is visible to all users.
	 * - `private` Event is visible only to the members of the event.
	 * - This can be used to control who can see and interact with the event.
	 */
	visibility: 'draft' | 'public' | 'private'

	/**
	 * Blackout periods for the event
	 * - `blackoutPeriods.start` Start time of the blackout period in milliseconds since epoch.
	 * - `blackoutPeriods.end` End time of the blackout period in milliseconds since epoch.
	 * - This is used to prevent scheduling the event during these times.
	 * - If the schedulingMethod is 'flexible', this will be used to determine available times for the event.
	 * - If the schedulingMethod is 'fixed', this will be ignored.
	*/
	blackoutPeriods?: ITimeRange[]

	/**
	 * Preferred times for the event
	 * - `preferredTimes.start` Start time of the preferred time range in milliseconds since epoch.
	 * - `preferredTimes.end` End time of the preferred time range in milliseconds since epoch.
	 * - This is used to suggest times for the event, but does not guarantee that the event will be scheduled at these times.
	 * - If the schedulingMethod is 'flexible', this will be used to determine the best time for the event.
	 * - If the schedulingMethod is 'fixed', this will be ignored.
	*/
	preferredTimes?: ITimeRange[]

	/**
	 * Intra-day start constraint for the event, in ms of the day
	 * - `dailyStartConstraints.start` Start time of the constraint in milliseconds since start of day.
	 * - `dailyStartConstraints.end` End time of the constraint in milliseconds since start of day.
	 * - This is used to prevent scheduling the event outside of these times. This only applies to the start time of the event.
	 * - If the schedulingMethod is 'flexible', this will be used to determine available times for the event.
	 * - If the schedulingMethod is 'fixed', this will be ignored.
	 */
	dailyStartConstraints?: ITimeRange[]

	/** Created at timestamp */
	createdAt: string
	/** Updated at timestamp */
	updatedAt: string
}

const timeRangeSchema = new Schema<ITimeRange>({
	start: {
		type: Schema.Types.Number,
		validate: {
			validator: function (this: ITimeRange, v: number | undefined) {
				if (v == null && this.end != null) { return false }
				if (v != null && v <= 0) { return false }
				return true
			},
			message: 'Start time must be provided and positive if end time is set'
		}
	},
	end: {
		type: Schema.Types.Number,
		validate: {
			validator: function (this: ITimeRange, v: number | undefined) {
				if (v == null && this.start != null) { return false }
				if (v != null && (this.start == null || v <= this.start)) { return false }
				return true
			},
			message: 'End time must be provided if start is set and must be greater than start'
		}
	}
}, { _id: false })

// 0..86,400,000 ms-of-day range for daily start constraints
const dailyRangeSchema = new Schema<ITimeRange>({
	start: {
		type: Schema.Types.Number,
		validate: {
			validator: function (this: ITimeRange, v: number | undefined) {
				if (v == null && this.end != null) { return false }
				if (v != null && (v < 0 || v > 86_400_000)) { return false }
				return true
			},
			message: 'Start must be between 0 and 86,400,000 milliseconds when end is set'
		}
	},
	end: {
		type: Schema.Types.Number,
		validate: {
			validator: function (this: ITimeRange, v: number | undefined) {
				if (v == null && this.start != null) { return false }
				if (v != null && (this.start == null || v === this.start || v < 0 || v > 86_400_000)) { return false }
				return true
			},
			message: 'End must differ from start and be between 0 and 86,400,000 milliseconds'
		}
	}
}, { _id: false })

const memberSchema = new Schema<IMember>({
	userId: {
		type: Schema.Types.ObjectId,
		ref: 'User',
		required: true
	},
	role: {
		type: Schema.Types.String,
		required: true,
		enum: ['creator', 'admin', 'participant'],
		default: 'participant'
	},
	customPaddingAfter: {
		type: Schema.Types.Number,
		min: [0, 'Custom padding must be non-negative']
	},
	availabilityStatus: {
		type: Schema.Types.String,
		required: true,
		enum: ['available', 'unavailable', 'invited'],
		default: 'invited'
	}
}, { _id: false })

const eventSchema = new Schema<IEvent>({
	name: {
		type: Schema.Types.String,
		required: true,
		trim: true,
		minLength: [1, 'Event name is too short (minimum 1 character)'],
		maxLength: [50, 'Event name is too long (maximum 50 characters)']
	},
	description: {
		type: Schema.Types.String,
		trim: true,
		maxLength: [1000, 'Event description is too long (maximum 1000 characters)']
	},
	members: {
		type: [memberSchema],
		required: true,
		validate: [
			{
				validator (members: IMember[]) {
					return members.length > 0
				},
				message: 'Event must have at least one participant'
			},
			{
				validator (members: IMember[]) {
					return members.some(member => member.role === 'creator')
				},
				message: 'Event must have at least one creator'
			},
			{
				validator (members: IMember[]) {
					const ids = members.map(m => String(m.userId))
					return new Set(ids).size === ids.length
				},
				message: 'Members must be unique by userId'
			},
			{
				validator (members: IMember[]) {
					if (members.length === 0) { return true }
					return members[0].role === 'creator'
				},
				message: 'First member must be a creator'
			},
			{
				// Verify all member userIds are valid ObjectIds and exist
				validator: async function (this: IEvent, members: IMember[]) {
					const userIds = members.map(m => m.userId)
					const existingUsers = await UserModel.find({ _id: { $in: userIds } })
					const existingUserIds = existingUsers.map(u => String(u._id))
					return userIds.every(id => existingUserIds.includes(String(id)))
				},
				message: 'All members must reference existing users'
			}
		]
	},
	schedulingMethod: {
		type: Schema.Types.String,
		required: true,
		enum: ['fixed', 'flexible'],
		default: 'fixed',
		validate: [
			{
				validator: function (this: IEvent, v: string) {
					if (v === 'flexible' && this.timeWindow == null) {
						return false
					}
					return true
				},
				message: 'Flexible scheduling requires a time window'
			},
			{
				validator: function (this: IEvent, v: string) {
					if (v === 'fixed' && this.scheduledTime == null) {
						return false
					}
					return true
				},
				message: 'Fixed scheduling requires a scheduled time'
			}
		]
	},
	timeWindow: {
		type: timeRangeSchema,
		validate: [
			{
				validator: function (this: IEvent, v: ITimeRange | undefined) {
					if (this.schedulingMethod !== 'flexible' || v == null) { return true }
					const { start } = v
					if (typeof start !== 'number') { return false }
					const now = Date.now()
					return start >= now
				},
				message: 'For flexible scheduling, timeWindow.start must be in the future'
			}
		]
	},
	duration: {
		type: Schema.Types.Number,
		required: true,
		min: [60000, 'Event duration (${VALUE}) must be at least 60000ms (1 minute)']
	},
	status: {
		type: Schema.Types.String,
		required: true,
		enum: ['scheduling', 'confirmed', 'cancelled'],
		default: 'scheduling',
		validate: {
			validator: function (this: IEvent, v: string) {
				if (v === 'confirmed' && this.scheduledTime == null) {
					return false
				}
				return true
			},
			message: 'Confirmed events must have a scheduled time'
		}
	},
	visibility: {
		type: Schema.Types.String,
		required: true,
		enum: ['draft', 'public', 'private'],
		default: 'draft'
	},
	scheduledTime: {
		type: Schema.Types.Number,
		validate: {
			validator (this: IEvent, v: number | undefined) {
				if (v == null) { return true }
				if (this.schedulingMethod === 'fixed') {
					return typeof v === 'number' && v > 0
				}
				if (this.schedulingMethod === 'flexible') {
					const start = this.timeWindow?.start
					const end = this.timeWindow?.end
					if (typeof start !== 'number' || typeof end !== 'number') { return false }
					return v >= start && (v + this.duration) <= end
				}
				return true
			},
			message: (props: { value: number }) => `Scheduled time (${props.value}) is invalid for the current scheduling method or outside constraints.`
		}
	},
	blackoutPeriods: [timeRangeSchema],
	preferredTimes: [timeRangeSchema],
	dailyStartConstraints: [dailyRangeSchema]
}, {
	timestamps: true
})

eventSchema.index({ 'members.userId': 1 })
eventSchema.index({ status: 1 })
eventSchema.index({ 'timeWindow.start': 1, 'timeWindow.end': 1 })
eventSchema.index({ scheduledTime: 1 })

eventSchema.pre('save', function (next) {
	if (this.schedulingMethod === 'fixed') {
		// If fixed scheduling, ensure time constraints are not set
		this.timeWindow = undefined
		this.blackoutPeriods = undefined
		this.preferredTimes = undefined
		this.dailyStartConstraints = undefined

		// Set status to confirmed if not already set
		this.status = 'confirmed'

		if (this.isNew) {
			// If new event, ensure timeWindow is not set
			this.timeWindow = undefined
		}
	} else if (this.schedulingMethod === 'flexible') {
		if (this.isNew) {
			// If new event, ensure scheduledTime is not set
			this.scheduledTime = undefined
		}
	}
	next()
})

const EventModel = model<IEvent>('Event', eventSchema)

export default EventModel
